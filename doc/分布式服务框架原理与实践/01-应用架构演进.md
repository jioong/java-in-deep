# 应用架构演进

通过将业务公共能力抽象成原子服务，对复杂应用进行水平拆分和服务化，实现服务消费者和提供者的解耦。
公共能力抽取和复用可以有效降低公共模块重复开发建设的成本。

## 传统垂直应用架构

垂直应用架构技术比较单一、学习成本低、开发上手快，测试部署和运维也比较简单。

**它的缺点：**
1. 复杂应用的开发维护成本变高、部署效率逐渐降低。
2. 团队协作效率变差，部分公共功能重复开发，代码重复率居高不下。
3. 系统的可靠性变差。高并发、大流量堆系统的可靠性要求非常高。垂直架构将所有的应用模块都部署在同一个进程中，如果某个应用接口发生故障，
将会导致整个节点宕机。对于对等集群部署，宕机可能会此起彼伏。
4. 维护和定制困难。代码修改牵一发而动全身。
5. 新功能上线周期变长。主要有两个原因导致交付效率下降。
    1. 公共API变更导致测试工作量激增。会引入大量的回归测试。
    2. 新特性无法独立部署和交付。
    
将公共能力API抽取出来，作为独立的公共服务供其他调用者消费，以实现服务的共享和重用，降低开发和运维成本。

## RPC架构

PRC全称是*Remote Procedure Call*，它是一种**进程间通信方式**。允许像调用本地服务一样调用远程服务。

PRC的特点：
1. 简单。
2. 高校。过程调用看起来十分简单而且高效。
3. 通用。跨进程调用最重要的是通用的通信机制。

### RPC框架的原理

RPC框架负责屏蔽底层的传输方式(TCP或UDP)、序列化方式(XML/JSON/二进制)和通信细节。
框架使用者只需要了解**谁在什么位置提供了什么样的远程服务接口即可**，开发者不需要关心底层通信细节和调用过程。

**RPC框架的技术核心点：**
1. 远程服务提供者需要以某种形式提供服务调用相关信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。服务调用者需要通过一定途径获取远程服务调用相关信息。
2. 远程代理对象。服务调用者调用的服务实际是远程服务的**本地代理**。它就是JDK的动态代理，通过动态代理的**拦截机制**，将本地调用封装成远程服务调用。
3. 通信。RPC框架与具体的协议无关。
4. 序列化。远程通信需要将对象转换成二进制码流进行网络传输，不同的序列化框架支持的数据类型、数据包大小、异常类型及性能等都不同。

服务发布者的主要职责如下：
* 作为服务端，监听客户端的TCP连接，接收到新的客户端连接之后，将其封装成Task，有线程池执行。
* 将客户端发送的码流发序列化成对象，反射调用服务实现者，获取执行结果。
* 将执行结果对象反序列化，通过Socket发送给客户端。
* 远程服务调用完成之后，释放Socket等连接资源。

本地服务代理的主要功能如下：
* 将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用。
* 创建Socket客户端，根据指定地址连接远程服务提供者。
* 将远程服务调用者所需的接口类、方法名、参数列表等编码后发送给服务提供者。
* 同步阻塞等待服务端返回应答，获取应答之后返回。

### 主流RPC框架

1. 由Facebook开发的`Apache Trift`。
2. Hadoop的子项目`Avro-RPC`。
3. caucho提供的基于`binary-RPC`实现的远程通信框架`Hessian`。
4. Google开源的基于HTTP/2和ProtoBuf的通用RPC框架`gRPC`。

### RPC框架面临的挑战

随着业务的发展，服务间的依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动。

## SOA服务化架构

SOA是一种粗粒度、送耦合的以服务为中心的架构，接口之间通过定义明确的协议和接口进行通信。

### 面向服务设计的原则

1. 服务可重用。不管是否存在即时复用的机会，服务均被设计为支撑潜在的可复用。
2. 服务共享一个标准契约。为了与服务提供者交互，消费者需要导入服务提供者的服务契约。可以是**IDL文件，Java接口，WSDL文件**。
3. 服务是送耦合的。服务被设计为功能相对独立、尽量不依赖其他服务的独立功能提供者。
4. 服务是底层逻辑的抽象。只有经服务契约所暴露的服务对外部世界可见。
5. 服务是可组合、可编排的。多个服务能被编排组合成一个新的服务。
6. 服务是自治的。逻辑由服务所控制，并位于一个清晰的边界内，服务已经在边界内被控制，不依赖其他服务。
7. 服务是无状态的。服务应当不需要管理状态信息，因此能改维持松耦合性。**服务应当被尽可能地设计成无状态的。**
8. 服务是可被自动发现的。服务上线后，允许被其他消费者自动发现。当服务下线后，允许消费者接收服务下线通知。

### 服务治理

1. 服务定义。SOA治理最基础的方面就是监视服务的创建过程。必须堆服务进行标识，描述其功能，确定其行为范围并设计其接口。
2. 服务生命周期管理。服务需要进行规划、设计、实现、部署、维护和下线。
3. 服务版本治理。服务发布不久之后，服务提供者就开始根据需要对副去进行修改，之后会**发布新版本的服务**。新版本的前向兼容性、灰度发布等需要按照统一的策略进行管理。
4. 服务注册中心。
5. 服务监控。需要对服务的调用时延、成功率、吞吐率等数据进行实时采样和汇总。
6. 运行期服务质量保证。包括服务限流、服务迁入迁出、服务升降级、服务权重调整和服务超时控制等，通过运行期的动态治理，可以在不重启服务的前提下达到快速提升服务运行质量的目标。
7. 快速的故障定位手段。故障定界定位主要包括：
    1. 大规模分布式环境下海量业务/平台日志的采集、汇总和实时在线检索，可以快速的查看各种系统运行日志。
    2. 分布式消息跟踪。
8. 服务安全。是否允许任何人调用服务，数据敏感型服务是否允许所有用户访问所有数据，服务使用者和提供者之间交换的数据是否需要进行保护，服务是否需要做安全认证，对内对外安全策略差异等。

## 微服务

微服务是一种服务化**架构风格**，通过将功能分散到各个离散的服务中以实现堆解决方案的解耦。

### 什么是微服务

微服务架构的主要特征如下：
1. 原子服务，专注做一件事。
2. 高密度部署。重要的服务可以独立进程部署，非核心服务可以独立打包到一个进程中。
3. 敏捷交付。服务由小的研发团队负责。
4. 微自治。服务足够小，功能单一，可以独立打包、部署、升级、回滚和弹性伸缩，不依赖其他服务，实现局部自治。

### 微服务与SOA对比

两者的差异：
1. 服务拆分粒度。
2. 服务依赖。
3. 服务规模。
4. 架构差异。微服务化之后，服务数量激增会引起架构质量属性的变化，为了保证高性能、低时延，需要高性能的分布式服务框架保证微服务架构的实施。
5. 服务治理。
6. 敏捷交付。