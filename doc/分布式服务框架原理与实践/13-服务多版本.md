# 服务多版本

服务上线之后，随着业务的发展需要对功能进行变更，或者修复线上的BUG。服务升级之后，往往需要堆服务采用多版本管理。

## 服务多版本管理设计

服务多版本管理对象包括服务提供者和消费者。
* 服务提供者，发布服务的时候，支持指定服务的版本号。
* 服务消费者，消费服务的时候，支持指定引用服务的版本号或版本范围。

### 服务版本号管理

服务的版本号是有序的，在服务名相同的情况下，不同服务版本的版本号可以比较大小。完整的版本号由**主版本号+副版本号+微版本号**构成。其中：
* 主版本号，表示重大特性或功能变更，接口或者功能可能不兼容。
* 副版本号，发生了少部分功能修改，或者新增了一些功能。
* 微版本号，主要用于BUG修复。

服务版本比较的原则：从前往后逐项比较，当且仅当服务名、主版本号、副版本号、微版本号相同的时候才是同一个服务。

### 服务提供者

为了方便对服务进行物理管理，打包后的名称会包含服务的版本信息。

### 服务消费者

服务消费者往往不需要指定具体依赖的服务版本，而是一个版本范围。

在服务框架中引入版本范围的原因如下：
1. 消费者关心的是某个新特性从哪个服务版本中开始提供，它并不关心服务提供者的版本演进以及具体的版本号。
2. 消费者想使用当前环境中服务的最新版本，但并不清楚具体的版本号，希望自动适配最新的服务版本。

### 基于版本号的服务路由

服务提供者将服务注册到注册中心的时候，将**服务名+服务版本号+服务分组**作为路由信息存放到注册中心，服务消费者在发起服务调用的时候，除了指定服务名还需要携带服务版本信息，
由路由接口负责服务版本过滤。

### 服务热升级

> 服务热升级的目标就是在业务不中断的情况下，实现系统的平滑升级。

服务热升级的核心点如下：
1. 升级的节点需要重启。但由于分布式服务框架具备服务的健康检查和自动发现机制，停机升级的节点会自动被隔离，停机并不会中断业务。
2. 服务路由规则的定制。
3. 滚动升级和回退机制。滚动升级也就是分批次的对服务进行热升级。