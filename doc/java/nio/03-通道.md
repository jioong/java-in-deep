# 通道

`Channel`用于在字节缓冲区和位于通道另一侧的实体(通常是一个文件或套接字)之间有效的传输数据。

通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的IO服务。缓冲区则是通道内部用来发送和接收数据的端点。

## 通道基础

1. `Channel`接口只有`isOpne(), close()`两个方法。
2. `InterruptibleChannel`是一个**标记接口**，当被通道使用时可以标示该通道是可以中断的。

### 打开通道

有文件通道和套接字通道。
* FileChannel
* SocketChannel
* ServerSocketChannel
* DatagramChannel

SocketChannel有可以直接创建新sokcet通道的方法。但是,FileChannel对象只能通过一个打开的`RandomAccessFile, FileInputStream, FileOutputStream`对象上
调用`getChannel()`方法来获取。

### 使用通道

通道将数据传输给ByteBuffer对象或者从ByteBuffer对象获取数据进行传输。

**单向通道**，只能在一个方向上传输数据：
* `ReadableByteChannel`接口定义了`read()`方法
* `WritableByteChannel`接口定义了`write()`方法
**双向通道**，当一个同时实现上面两个类时,可以双向传输数据，
* `ByteChannel`

一个连接到只读文件的channel实例不能进行写操作，即使该实例所属的类可能有write()方法。

非阻塞模式的通道永远不会让调用的线程休眠。只有面向流的通道才能使用非阻塞模式。

### 关闭通道

与缓冲区不同，通道不能被重复使用。一个打开的通道即代表与一个特定IO服务的特定连接并封装该连接的状态。当通道关闭时，那个连接会丢失，然后通道就不再连接任何东西。

## Scatter/Gather

它们是指在多个缓冲区上实现一个简单的IO操作。
对于一个write操作而言，数据是从几个缓冲区按照顺序抽取(gather)并沿着通道发送的。缓冲区本身并不具备这种gather能力。该*gather*过程的效果好比**全部缓冲区
的内容被连接在一起**，并在发送数据前存放到一个大的缓冲区中。
对于一个read操作而言，从通道读取的数据会被按照顺序被散步(scatter)到多个缓冲区，将每个缓冲区填满直到通道中的数据或缓冲区的最大空间被耗完。

> 将读取的数据分开存放到多个存储桶中，或者将不同的数据区块合并成一个整体。

节省了来回移动数据的工作，也避免了缓冲区拷贝。基本上只需要**提供数据容器引用来组合数据。**

## 文件通道

文件通道总是阻塞式的，不能被置于非阻塞模式。

FileChannel对象是**线程安全**的，多个进程可以在同一个实例上并发调用方法而不会引起任何问题。