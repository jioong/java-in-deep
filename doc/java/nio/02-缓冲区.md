# 缓冲区

一个Buffer对象是固定数量的数据的容器。其作用是一个存储器，或分段运输区，在这里数据可以被存储并在之后用于检索。

> 对于每个非布尔原始数据类型都有一个缓冲区类。

## 缓冲区基础

缓冲区是包在一个对象内的基本数据元素数组。

### 属性

1. 容量Capacity,缓冲区能够容纳的数据元素的最大数量。**这一容量是在缓冲区创建时设定的，并且永远不能被改变。**
2. 上界Limit，缓冲区的第一个不能被读或写的元素。或者说，**缓冲区中现存元素的计数。**
3. 位置Position，下一个要被读或写的元素的索引。位置会由相应的get()或put()方法更新。
4. 标记Mark，一个备忘位置。调用`mark()`设置`mark=position`。调用`reset()`设定`position=mark`。标记在设定前是未定义的。

它们遵循关系：
`0 <= mark <= position <= limit <= capacity`

**容量是固定的，但其他三个属性可以在使用缓冲区时改变。**

### 缓冲区 API

`java.nio`中的的类特意的被设计为支持级联调用。
> 所有缓冲区都是可读的，但并非所有的都可写。可以通过`isReadOnly()`方法来判断。  
> 缓冲区不是线程安全的。

1. 翻转操作 `flip()`，**表示准备将缓冲区清空**。
    `buffer.flip()`等同于`buffer.limit(buffer.position()).position(0)`
    上界属性指明了缓冲区有效内容的末端。该方法将一个能够添加数据元素的**填充状态**的缓冲区翻转成一个准备读出元素的**释放状态**。
    如果连续调用该方法两次，则会使得`position, limit`都为0。
2. `rewind()` 与 flip()类似，它**不影响上界属性，只是将位置值设置为0**。
    它可以实现**回退**，重读已经被翻转的缓冲区中的数据。
3. `hasRemaining()`会在释放缓冲区时判断是否已达到缓冲区的上界。
4. `remaining()`将告知从当前位置到上界还剩余的元素数目。
5. `clear()`将缓冲区重置为空状态。它不改变缓冲区中的任何数据元素，而是仅仅将上界值设定为容量值，并把位置设置为0。
6. 压缩 `compact()`,可以满足只从缓冲区中释放了一部分数据，然后重新填充的需求。调用该方法之后：
    1. `position`到最后一个数据元素平移到缓冲区的开头，即索引为`0`的元素设置为`position`位置的元素值，以此类推。
    2. `position`设置为被复制元素的数目。
    3. `limit`设置为缓冲区容量的值。
    
    该方法的目的是，丢弃已经读取过的数据，保留未释放的数据。**如果压缩后想要读取数据，需要调用翻转操作。**
7. 标记 `mark()`,使缓冲区能够记住一个位置并在之后将其返回。调用时将标记设置为当前位置值。
8. `reset()` 将位置设置为当前的标记值。如果标记值未定义，将抛出异常。
    * 调用`rewind(), clear(), filp()`方法总是会**抛弃标记**。
    * 调用`limit(), position()`带索引参数的版本，如果新设定的值比当前的标记小，则会**抛弃标记**。
9. 比较 `equals()`,如果每个缓冲区中剩余的内容相同，则返回`true`，否则返回`false`。两个缓冲区认为是相等的**充要条件**：
    * 两个对象类型相容。
    * 两个对象剩余同样数量的元素。Buffer不需要相同，而且缓冲区剩余元素的索引不需要相同。
    * 在每个缓冲区中应被`get()`方法返回的剩余数据元素序列必须一致。
10. 批量移动，缓冲区的目的是为了高效传输数据。批量移动总是具有指定的长度。
    * 如果所要求的数量的数据不能被传送，也就是说缓冲区中的数据的数量不够，那么不会有数据被传递。缓冲区中的状态保持不变，并且会抛出异常。
    * 当从数组向缓冲区中填数据时，如果缓冲区有足够的空间接受数组中的数据(`buffer.remaining() >= array.length()`),数据将会被复制到从当前位置开始的缓冲区，
    并且缓冲区位置会提前所增加数据元素的数量。
    * 如果 缓冲区没有足够的空间，那么不会有数据被传递，同时抛出一个异常。
    
## 创建缓冲区

新的缓冲区是由分配或包装操作所创建的。
1. 分配操作创建一个缓冲区对象并分配一个私有的空间来存储容量大小的数据元素。
2. 包装操作创建一个缓冲区对象但是不分配任何空间来存储数据元素。它使用所提供的数组作为存储空间来存储缓冲区中的数据元素。
    * 调用`put()`方法造成的对缓冲区的改动会直接影响这个数组。
    * 同时，对这个数组的任何改动也会对这个缓冲区对象可见。

* `public static CharBuffer allocate(int capacity)`
* `public static CharBuffer wrap(char[] array)`
* `public static CharBuffer wrap(char[] array, int off, int len)`
    * 创建一个`position = off， limit = len, capacity = array.length`的缓冲区。
    * 该缓冲区可以存取该数组的全部范围。`off, len`只是设置了初始状态
    
通过`allocate(), wrap()`方法创建的缓冲区通常都是间接的。
> 间接的缓冲区使用备份数组。`hasArray()`方法判断这个缓冲区是否有一个可存取的备份数组。如果这个方法返回为`true`，`array()`方法返回这个缓冲区对象的
数组存储空间的引用。

* `arrayOffset()`，返回缓冲区数据在数组中存储的开始位置的偏移量，从数组头0开始计算。

## 复制缓冲区

> 当一个管理其他缓冲器所包含的数据元素的缓冲器被创建时，这个缓冲器被称为视图缓冲器。大多数视图华纳重启都是ByteBuffer的视图。

视图存储器总是通过调用已存在的存储器实例中的方法来创建，使用已存在的存储器实例中的工厂方法意味着视图对象为原始存储器的内部实现细节私有。

**所有缓冲区共有的操作：**
1. `duplicate()` 创建一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有相同的`capacity`，但每个缓冲区拥有各自的`position， limit, mark`属性。
    对一个缓冲区内数据元素所做的改变会反映到另一个缓冲区上。这一缓冲区副本具有与原始缓冲区同样的数据视图。
    * 如果原始缓冲区为只读，或者直接缓冲区，新的缓冲区将继承这些属性。
    * 复制一个缓冲区会新建一个buffer对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素。
2. `asReadOnlyBuffer()`来生成一个只读缓冲区视图。其他的则与`duplicate()`相同。
    * 如果一个只读缓冲区与一个可写缓冲区共享数据，或者有包装好的备份数组，那么对这个可写缓冲区或直接对这个数组的改变将反映**在所有关联的缓冲区上，包括只读缓冲区。**
3. `slice()` 创建一个从原始缓冲区的当前位置开始的新的缓冲区。并且其`capacity`是原始缓冲区的剩余元素数量(limit-position)。
    * 新的缓冲区与原始缓冲区共享一段数据元素子序列。
    * 分割出来的缓冲区也会继承只读和直接属性。
    
## 字节缓冲区

字节缓冲区较为独特。字节是操作系统及其IO设备使用的基本数据类型，当在JVM和操作系统之间传递数据时，将其他的数据类型拆分成构成它们的字节是十分必要的。

### 字节顺序

> 如果数字数值的最高字节(big end)，位于低地址，那么系统就是大端字节序。如果最低字节最先保存在内存中，那么是小端字节序。

在`java.nio`中，字节序由`ByteOreder`类封装。

对于除字节缓冲区之外的其他缓冲区，字节顺序是一个只读属性。
`ByteBuffer`类有所不同，默认字节顺序总是`ByteOrder.BIG_ENDIAN`，无论系统的固有字节顺序是什么。

### 直接缓冲区

字节缓冲区与其他缓冲区最大的不同在于，**它可以成为通道所执行的IO的源头或目的地。**  
> 通道只接受ByteBuffer作为参数。只有字节缓冲区有资格参与IO操作。

直接缓冲区被用于与通道和固有IO例程交互。它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储
尽了最大的努力。

**直接字节缓冲区通常是IO操作的最好选择。**如果向一个通道中传递一个非直接ByteBuffer对象用于写入，通道可能会隐含的进行如下操作：
1. 创建一个临时的直接ByteBuffer对象。
2. 将非直接缓冲区的内容复制到临时缓冲区中。
3. 使用临时缓冲区执行低层次IO操作。
4. 临时缓冲区对象离开作用域，并最终成为被回收的无用数据。

直接缓冲区的创建会比非直接缓冲区的创建要话费更高的成本。直接缓冲区使用的内存是通过本地调用操作系统方面的代码分配的，。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区
更加破费。

`ByteBuffer.allocateDirect()`创建直接缓冲区。

> ByteBuffer是唯一可以直接分配的类型。但是如果基础缓冲区是一个直接ByteBuffer，对于非字节视图缓冲区，`isDirect()`可以返回`true`。

### 视图缓冲区

> 视图缓冲区通过已存在的缓冲区对象实例的工厂方法来创建。这种视图对象维护自己的属性`capacity, position, limit, mark`,但是和原有缓冲区共享数据元素。

ByteBuffer缓冲区允许创建视图来将byte型缓冲区字节数据映射为其他原始数据类型。
视图缓冲区中的第一个元素从创建它的ByteBuffer对象的`position`开始。

### 数据元素视图

