**InputStream API**

1. read(): int  
    * 该方法从输入流中读取下一个 byte  
    * 返回值范围为 0 - 255  
    * 当输入流结束没有可读的字节时，返回 -1  
    * 该方法会**阻塞**，直到:1)输入数据可用, 2)检测到输入流结束, 3)抛出异常 `IOException`   
2. read(byte[] b): int   
    * 该方法从输入流中读取一些`byte`,并存入缓存数组`b`中
    * 返回值为实际读取的字节数
    * 该方法也会阻塞
    * 如果数组`b`的长度为0，则表示一个字节都没有读入，并返回 0，
    * 否则，它会尝试**至少**读入一个字节。如果是因为到达输入流的末尾 ，则会返回 -1，
    * 否则，知道有一个字节会被读取并存入`b`中。
    * 数组`b`的下标从 0 开始，每次最多读入的字节数为数组`b`的长度
    * 如果实际读入的字节数小于数组的长度，则数组的后面剩下的元素不会被改变
    * 当1)不管因为任何原因一个字节都读取不到，但是又没到输入流的末尾，2)输入流被关闭，3)出现I/O错误时，会抛出`IOException`
    * 当输入参数`b`为`null`时，抛出`NullPoniterException`
3. read(byte[] b, int off, int len): int  
    * 向数组`b`中*争取***读入指定长度`len`的字节数，实际读入字节数可能小于`len`,返回值为实际读入的字节的数目
    * 该方法也会阻塞
    * 如果,`len`为 0 则不会读入任何字节，并返回 0 ,
    * 否则，会尝试读入至少一个字节。如果因为到达输入流的末尾而读取不到数据，则返回 -1
    * 读入的**第一个**存储在`b[off]`元素中
    * 在任何情况下，`b[0] - b[off]` 和 `b[off + len] - b[b.length - 1]`之间的元素都不会被影响
    * 该方法实际上只是重复的调用`read()`,当`read()`方法抛出异常被它捕获时，它什么都不处理，直接返回异常抛出前已读入数组`b`的实际字节数
    * 该方法的默认实现会阻塞，直到1)读入`len`个字节，2)到达输入流的末尾，3)抛出异常。
    * 比方法(2)多抛出异常`IndexOutOfBoundsException`,当`len, off`中任意一个为负数，或者`len > b.length - off`
4. skip(long): long  
    * 跳过并丢弃输入流的前`n`个字节。
    * 该方法可能会一些原因，实际跳过的字节数**小于**指定的字节数，也可能跳过数为 0,这样的原因可能是：  
        * 在达到输入流的末尾时没能跳过指定长度的字节数,返回值为实际跳过的字节的数目。
    * 如果输入参数为负数，则总是返回值为 0，且不会跳过任何一个字节。**该类的子类可以用不同的方法处理参数为负的情况。**
    * 该方法能跳过的最大字节数为 2048。
    * 当处理的流不支持重定位`seek`或发生其他IO错误时，会抛出`IOException`
5. available(): int
    * 该方法返回一个**预估**的输入流中还能读取或跳过的字节数(不阻塞的情况下啊可获取的字节数)，它不会阻塞该输入流的下一个方法的调用。下一个方法调用可能与它是同一个线程或不同线程。
    * 用该方法的返回值去分配内存空间来存储该输入流中的所有数据**总是错误**的。
    * 该方法总是返回  0，需要在子类中被重写。
    * 当输入流被`close()`后调用该方法，需要抛出`IOException`.
6. close(): void
    * 关闭输入流并释放该输入流关联的系统资源。
7. mark(int readlimit): void
    * 在输入流的当前位置设置**标志位**,当后续调用`reset()`方法时，输入流会**重定位**到设置标志位的地方，这样就可以`re-read`相同的字节。
    * 输入参数`readlimit`,告诉输入流在接下来继续读入`readlimit`字节前，设置的标志位是有效的。当读取的字节数超出该参数，则设置的标志位无效。
    * 该方法的契约是：1)当输入流的`markSupported`方法返回值为`true`时，该输入流会记住所有调用`mark()`方法后读取的字节，并准备去重新使用这些
        字节当`reset()`方法被调用的情况下。2)如果在`reset()`方法调用之前 ，该输入流已经读取了超过`readlimit`的字节数，则该输入流不用保存任
        何数据。
    * 标记一个已关闭的输入流不会有任何影响。
8. reset(): void
    * 将输入流重定位到上一个`mark()`方法调用时输入流所在的位置。
    * 该方法的契约是：
        1) 当`markSupported`方法返回为`true`时：
            * 如果该输入流1)还没有调用过`mark()`方法或2)调用`mark()`方法后读取的字节数超过了指定的字节数，则会抛出`IOException`.
            * 如果没有抛出`IOException`,则输入流会回到上一个`mark()`调用时的状态(或者到输入流的开头，如果没有调用`mark（）`),也就是说调用
            `mark()`方法后被读取过的字节可以再次被读取。
        2) 当返回值为`false`时：
            * 调用该方法会抛出`IOException`
            * 如果没有抛出`IOException`,则输入流会根据其具体类型重置为一个固定状态,接下来则可读取输入流中的字节。
9. markSupported(): boolean
    * 该方法用于测试输入流是否支持`mark(), reset()`方法。