**InputStream API**

1. read(): int  
    * 该方法从输入流中读取下一个 byte  
    * 返回值范围为 0 - 255  
    * 当输入流结束没有可读的字节时，返回 -1  
    * 该方法会**阻塞**，直到:1)输入数据可用, 2)检测到输入流结束, 3)抛出异常 `IOException`   
2. read(byte[] b): int   
    * 该方法从输入流中读取一些`byte`,并存入缓存数组`b`中
    * 返回值为实际读取的字节数
    * 该方法也会阻塞
    * 如果数组`b`的长度为0，则表示一个字节都没有读入，并返回 0，
    * 否则，它会尝试**至少**读入一个字节。如果是因为到达输入流的末尾 ，则会返回 -1，
    * 否则，知道有一个字节会被读取并存入`b`中。
    * 数组`b`的下标从 0 开始，每次最多读入的字节数为数组`b`的长度
    * 如果实际读入的字节数小于数组的长度，则数组的后面剩下的元素不会被改变
    * 当1)不管因为任何原因一个字节都读取不到，但是又没到输入流的末尾，2)输入流被关闭，3)出现I/O错误时，会抛出`IOException`
    * 当输入参数`b`为`null`时，抛出`NullPoniterException`
3. read(byte[] b, int off, int len): int  
    * 向数组`b`中*争取***读入指定长度`len`的字节数，实际读入字节数可能小于`len`,返回值为实际读入的字节的数目
    * 该方法也会阻塞
    * 如果,`len`为 0 则不会读入任何字节，并返回 0 ,
    * 否则，会尝试读入至少一个字节。如果因为到达输入流的末尾而读取不到数据，则返回 -1
    * 读入的**第一个**存储在`b[off]`元素中
    * 在任何情况下，`b[0] - b[off]` 和 `b[off + len] - b[b.length - 1]`之间的元素都不会被影响
    * 该方法实际上只是重复的调用`read()`,当`read()`方法抛出异常被它捕获时，它什么都不处理，直接返回异常抛出前已读入数组`b`的实际字节数
    * 该方法的默认实现会阻塞，直到1)读入`len`个字节，2)到达输入流的末尾，3)抛出异常。
    * 比方法(2)多抛出异常`IndexOutOfBoundsException`,当`len, off`中任意一个为负数，或者`len > b.length - off`
4. skip(long): long
5. available(): int
6. close(): void
7. mark(int): void
8. reset(): void
9. markSupported(): boolean