# 面向切面的Spring

在软件开发中，散布于应用中多出的功能被称为**横切关注点(cross-cutting concern)**。通常来讲，这些横切关注点从概念上是与业务逻辑相互分离的，但是也
往往会直接嵌入业务逻辑之中。把这些横切关注点与业务逻辑相互分离正式面向切面编程(AOP)所要解决的问题。

> DI 有助于应用对象之间的解耦。AOP实现横切关注点与它们所影响的对象之间的解耦。

## 1. 什么是面向切面编程

横切关注点可以被描述为影响应用多处的功能。

> 使用面向切面编程时，任然在一个地方定义**通用功能**，但是可以通过**声明**的方式定义这个功能要**以何种方式在何处**应用，而无需修改受影响的类。

横切关注点可以被模块化为特殊的类，这些类被称为**切面 Aspect**。这样做有两个好处：
1. 每个关注点都集中在一个地方，而不是分散在多处代码中。
2. 服务模块更简洁。因为它们只包含要关注点的代码，而次要关注点的代码都被转移到切面中了。

### 1.1 定义AOP术语

1. 通知(Advice),切面的工作被称为通知。
    * 通知定义了切面是什么，以及何时使用。除了描述切面要完成的功能，通知还解决了何时执行这个工作的问题。
    * Spring 切面可以用于 5种类型的通知：
    * **前置通知(Before)**，在目标方法调用之前调用通知功能。
    * **后置通知(After)**，在目标方法完成之后调用通知，此时不会关注方法的输出是什么。
    * **返回通知(After-retturing)**，在目标方法**成功执行**之后调用通知。
    * **异常通知(After-throwing)**，在目标方法**抛出异常**后调用通知。
    * **环绕通知(Around)**，通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义行为。
2. 连接点(Join Point)，连接点是在应用执行过程中能够掺入切面的一个点。
    * 这个点可以是调用方法时、抛出异常时、甚至是修改一个字段时。
    * 切面代码可以利用这些点插入到应用的正常流程在宏，并添加新的行为。
3. 切点(Pointcut)，一个切面不需要通知应用的所有连接点，切点有助于缩小切面所通知连接点的范围。
    * 切点定义了**何处**。
    * 切点的定义会匹配通知所要**织入**的一个或多个连接点。
    * 切点与连接点是一对多的关系。
4. 切面(Aspect)，切面是通知和切点的结合。
    * 通知和切点共同定义了切面的全部内容,**它是什么，在何时和何处完成其功能。**
5. 引入(Introduction)，引入允许我们向现有的类中添加新方法或属性。
    * 该特性可以在无需修改现有类的情况下，让它们具有新的行为和状态。
6. 织入(Weaving)，织入是把切面应用到目标对象中并创建新的代理对象的过程。
    * 切面在指定的连接点被织入到目标对象中。
    * 在目标对象的生命周期里有多个点可以进行织入：
    * **编译期**，切面在目标类编译时被织入。*AspectJ*的织入编译器就是以这种方式织入切面的。
    * **类加载期**，切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载期，它可以在目标类被引用之前增强该目标类的字节码。
    * **运行期**，切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器回味目标对象动态地创建一个代理对象。`Spring AOP`以这种方式织入切面。
    
> 通知包含了需要用于多个应用对象的横切行为。连接点是程序执行过程中能够应用通知的所有点。切点定义了通知被应用的具体位置(在哪些连接点)。切面
定义了哪些连接点会得到通知。

### 1.2 Spring对AOP的支持

并不是所有的AOP框架都是相同的，它们在连接点模型上可能有强弱之分。

Spring提供了4种类型的AOP支持：
1. 基于dialing的经典`Spring AOP`.
2. 纯`POJO`切面。
3. `@AspectJ`注解驱动的切面。
4. 注入式`AspectJ`切面，适用于Spring各版本。

**Spring通知是Java编写的**

Spring所创建的通知都是用标准的`Java`类编写的。可以使用与普通的Java开发一样的IDE来开发切面。而且，定义通知所应用的切点通常使用注解或在Spring配置文件中
采用XML来编写。

**Spring在运行时通知对象**

通过在代理类中包裹切面，Spring在运行时把切面织入到Spring管理的`bean`中。
代理类封装了目标类，并拦截被通知方法的调用，再把调用转发啊给真正的目标`bean`。当代理拦截到方法的调用时，在调用目标`bean`之前，会执行切面逻辑。
直到应用需要被代理的`bean`时，Spring才创建代理对象。如果使用的是`ApplicationContext`的话，在`ApplicationContext`从`BeanFactory`中加载所有的
`bean`的时候，Spring才会创建被代理的对象。
因为Spring运行时才创建代理对象，所以不需要特殊的编译器来织入`Spring AOP`的切面。

**Spring只支持方法级别的连接点**

因为Spring是基于动态代理的，所以Spring只支持方法连接点。

如果需要方法拦截之外的拦截点功能，可以利用`AspectJ`来补充Spring的功能。

## 2. 通过切点来选择连接点

切点是用于准确定位应该在什么地方应用切面的通知。通知和切点是切面的最基本元素。

> Spring仅支持AspectJ切点指示器的一个子集。

如下为Spring AOP 所支持的AspectJ切点指示器：
1. `arg()` 限制连接点匹配参数为指定类型的执行方法。
2. `@args()` 限制连接点匹配参数由指定注解标注的执行方法。
3. `execution()` 用于匹配是连接点的执行方法。
4. `this()` 限制连接点匹配AOP代理的`bean`引用为指定类型的类。
5. `target` 限制连接点匹配目标对象为指定类型的类。
6. `@target()` 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解。
7. `within()` 限制连接点匹配指定的类型。
8. `@within()` 限制连接点匹配指定注解所标注的类型。
9. `@annotation()` 限定匹配带有指定注解的连接点。

在Spring AOP 中尝试使用AspectJ其他指示器时，会抛出`IllegalArgumentException`异常。
**注意：**只有`execution`指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。也就是说，其他指示器是 用来显示所匹配的切点，进行更精确范围更小的匹配。

### 2.1 编写切点

如：`execution(* path.to.Class.method(..))`
* 第一个`*`，表示不关系方法返回值的类型。
* 然后指定类名和方法名。
* 括号中为方法参数列表，`..`表示使用任意参数。

当需要限制切点时，可以使用其他指示器来限制。如`execution(* path.to.Class.method(..)) && within()`。

除了可以使用`&&`，还可以使用`||， ！`。

### 2.2 在切点中选择bean

除了上述的指示器，Spring还引入了一个新的`bean()`指示器，它允许在切点表达式中使用`bean`的`ID`来标识`bean`。
* `bean()`使用`bean ID`或`bean`名称作为参数来限制切点只匹配特定的`bean`。

## 3. 使用注解创建切面

使用注解创建切面是`AspectJ 5`中引入的关键特性。

### 3.1 定义切面

当使用JavaConfig时，可以在配置类的**类级别上**通过使用`@EnableAspectJAutoProxy`注解启用自动代理功能。

需要记住的是，Spring的AspectJ自动代理仅仅使用`@AspectJ`作为创建切面的指导，切面依然是基于代理的。在本质上，它依然是Spring基于代理的切面。如果想
利用AspectJ的所有能力，必须在运行时使用AspectJ并且不依赖Spring来创建基于代理的切面。

### 3.2 创建环绕通知

环绕通知是最为强大的通知类型。它能够让所编写的逻辑将被通知的目标的目标方法完全包装起来。实际上就像是在一个通知方法中同时编写前置通知和后置通知。

使用环绕通知时，必须要有`ProceedingJoinPoint`对象，因为要在通知中通过它来调用被通知的方法。通知方法中可以做任何事情，当要**将控制权交给被通知方法时**，
需要调用该对象的`proceed()`方法。

**注意：**不能忘记对`proceed()`方法的调用。如果不调用该方法，那么通知实际上会阻塞对被通知方法的调用。
* 可以不调用`proceed()`方法，阻塞对被通知方法的调用。
* 可以对`proceed()`方法进行多次调用。这样做的一个场景的实现**重试逻辑**。也就是被通知方法失败后，进行重复尝试。

### 3.3 处理通知中的参数

### 3.4 通过注解引入新功能

前面所使用的切面中，所包装的都是被通知对象的已有方法。但是，方法包装仅仅是切面所能实现的功能之一。
切面还可以为被通知的对象引入全新的功能。

利用称为**引入**的概念，切面可以为`Spring bean`添加新的方法。

> 当引入接口的方法被调用时，代理会把此调用委托给实现了新接口的某个其他对象。实际上，一个`bean`的实现被拆分到了多个类中。

## 3. 在XML中声明切面

在Spring中，注解和自动代理提供了一种便利的方式去创建切面。它只涉及少量的配置。但是它有一个劣势在于：**必须能够为通知类添加注解。也就意味着，必须要有源码。**

在Spring的`aop 命名空间`中，提供了多个元素用来在XML中声明切面。如
* `<aop:advisor>` 定义AOP通知器。
* `<aop:after>`  定义后置通知(不管被通知的方法是否执行成功)。
* `<aop:after-returing>` 定义AOP返回通知。
* `<aop:after-throwing>` 定义AOP异常通知。
* `<aop:around>` 定义AOP环绕通知。
* `<aop:aspect>` 定义一个切面。
* `<aop:aspectj-autoproxy>` 启动`@AspectJ`注解驱动的切面。
* `<aop:before>` 定义AOP前置通知。
* `<aop:config>` 顶层的AOP元素。大多数`<aop:*>`元素必须包含在该元素内。
* `<aop:declare-parents>` 以透明的方式为被通知的对象引入额外的接口。
* `<aop:pointcut>` 定义一个切点。