# 高级装配

## 1. 环境与profile

在软件开发的时候，一个很大的挑战就是将应用程序从一个环境迁移到另一个环境。

### 1.1 配置 profile bean

Spring能够在运行时来确定需要根据环境创建哪个`bean`和不创建哪个`bean`。这样的结果就是同一个 部署单元能够适用于所有环境，没有必要进行重新构建。
在3.1 版本中，Spring引入了`bean profile`功能。

> 要是使用profile，首先需要将所有不同的bean定义整理到一个或多个profile中，在将应用部署到每个环境时，要确保对应的profile处于激活状态。

在Java配置中，可以使用`@Profile`注解指定某个`bean`属于哪一个`profile`。

> 没有指定`profile`的`bean`始终都会被创建，与激活哪个`profile`没有关系。

**在XML中配置profile**

可以通过`<beans>`元素的`profile`属性，在XML配置文件中配置`profile bean`。

注意，可以在根`<beans>`元素中嵌套`<beans>`元素。

### 1.2 激活 profile

Sping在确定哪个`profile`处于激活状态时，需要依赖两个独立的属性：
* `spring.profiles.active`
    * 如果设置了该属性的话，它的值就会用来确定哪个`profile`是激活的。
* `spring.profiles.default`  
    * 如果上面的属性没有设置，Spring就会超照该属性的值。
* 如果上面两个属性都没有设置的话，那就没有激活的`profile`，因此只会创建没有定义在`profile`中的`bean`。

可以同时激活多个`profile`。可以通过列出多个`profile`名称，并以逗号分割来实现。

有多种方式来设置这两个属性：
* 作为`DispatcherServlet`的初始化参数。
* 作为WEB应用的上下文参数。
* 作为JNDI条目。
* 作为环境变量。
* 作为JVM的系统属性。
* 在集成测试类上，使用`@ActiveProfiles`注解设置。

## 2. 条件化的 bean

Spring 4 中引入了`@Conditional`注解，它可以用在带有`@Bean`注解的方法上。如果指定的条件计算结果为`true`,就会创建这个`bean`。否则的话，这个`bean`就会被忽略。

`matches()`方法会得到`ConditionContext， AnnotatedTypedMetaData`这两个对象。

`ConditionContext`是一个接口，借助它可以做到如下几点：  
* 借助`getRegistry()`返回的`BeanDefinitionRegistry`检查`bean`定义。
* 借助`getBeanFactory()`返回的`ConfigurableListableBeanFactory`检查`bean`是否存在，甚至探查`bean`的属性。
* 借助`getEnvironment()`返回的`Environement`检查环境变量是否存在以及它的值是什么。
* 读取并探查`getResourceLoader()`返回的`ResourceLoader`所加载的资源。
* 借助`getClassLoader()`返回的`ClassLoader`加载并检查类是否存在。

`AnnotatedTypedMetaData`同样是一个接口，能够帮助检查带有`@Bean`注解的方法上还有什么其他注解。
* 借助`isAnnotated()`方法，能够判断带有`@Bean`注解的方法是不是还有其他特定的注解。

## 3. 处理自动装配的歧义性

自动装配能够减少装配应用程序组件时所需的显示配置的数量。不过，仅有一个`bean`匹配所需的结果时，自动装配才是有效的。如果不只一个`bean`能够匹配结果的话，
这种歧义性会阻碍Spring自动装配属性、构造器参数或方法参数。

Spring提供多种可选方案来解决这样的问题。
1. 可以将可选`bean`中的某一个设置首先(primary)的`bean`。
2. 使用限定符(qualifier)来帮助Spring将可选的`bean`的范围缩小到只有一个`bean`。

### 3.1 标示首选的 bean

设置首选`bean`,就是告诉Spring在遇到歧义性的时候要选择首选的`bean`。
> 如果标示了两个或更多的首选`bean`,那么它就无法工作了。

### 3.2 限定自动装配的 bean