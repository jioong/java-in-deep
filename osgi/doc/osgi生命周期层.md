# OSGI 生命周期层

一般来说，程序(或程序的一部分)会显示或隐式地受到某种形式的声明周期的约束。
* 安装
* 执行
* 更新
* 移除
![生命周期](./img/life-cycle.jpg "生命周期")

* 通过在外部或者内部对应用进行这些操作，完成对应用”生命周期管理“的过程。
* 对于非模块化应用，这些操作就是以整个应用为对象的。
* 如果是对于模块化应用，就可以有更细粒度(针对应用中的某个模块)的声明周期管理。

## 生命周期层的作用

1. 在应用程序外部，生命周期层精确定义了对*bundle*生命周期的相关操作。
2. 对生命周期的操作，允许动态地改变运行与框架中*bundle*组成，并以此来管理和演化应用程序。
3. 在应用程序内部，生命周期层定义了*bundle*访问其执行上下文的方式，为*bundle*提供了一种与OSGI框架交互的途径以及一些执行时的便利条件。

![OSGI 生命周期](./img/life-cycle-module.jpg "OSGI 生命周期")

OSGI框架支持对*bundle*形式的JAR文件实现生命周期管理**安装、解析、启动、停止、更新和卸载**

![OSGI 生命周期状态转移](./img/life-cycle-status-transate.jpg "生命周期状态转移")

## 接入生命周期层

* 开始使用生命周期层的基础设施：*BundleActivator*。
* 调用`start()`方法的激活器实例与调用`stop()`的实例是同一个。
* 当`stop()`方法被调用后，激活器实例就被丢弃并不再使用。
* 如果一个*bundle*被停止后，又重新启动，那么将创建一个新的激活器实例，同时它的`start()`方法和`stop()`方法也将适时被触发。

## 使用生命周期层

1. `BundleContext`
    * 与部署与生命周期管理相关的接口
    * 与*bundle*间服务交互相关接口
2. 在`bundle`属于`active`状态时，`BundeleContext`才有意义，即`start`方法被调用和`stop`方法被调用的两个时间点之间。
3. 为了`bundle`的安全和资源分配，不应该被随意在`bundle`之间传递。



